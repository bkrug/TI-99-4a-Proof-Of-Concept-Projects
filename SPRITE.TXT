       DEF  RUNTST
       REF  SPR0,SPREND,SPRLEN

* A program to test shifting the screen left and right
* This scroll method involves defining grops of 8 characters
* Each character in the group is pixel-shifted by one
* relative to the earlier character.
*
* Use this file together with HSCROLLDAT and FIXEDDAT

* CPU RAM Addresses
USRISR EQU  >83C4        Address defining address of interupt routine
REG1CP EQU  >83D4        Address holding a copy of VDP Register 1
VDPWA  EQU  >8C02        VDP RAM write address
VDPRD  EQU  >8800        VDP RAM read data
VDPWD  EQU  >8C00        VDP RAM write data
VDPSTA EQU  >8802        VDP RAM status
* VDP RAM Addresses
SPRTBL EQU  >1800        Address of Sprite Pattern Table
CLRTBL EQU  >380         Address of Color Table
PTNPG1 EQU  >800         Address of Character Pattern Table 1
PTNPG2 EQU  >1000        Address of Character Pattern Table 2
SCNPG1 EQU  >0           Address of Page 1 of the screen image table
SCNPG2 EQU  >400         Address of Page 2 of the screen image table
SPRPG1 EQU  >2000        Address of Page 1 of the sprite attribute list
SPRPG2 EQU  >2080        Address of Page 2 of the sprite attribute list

*
* Editable values
*
       AORG >8300

LOCLWS BSS  >20          Local Workspace
       BSS  >8           8 Bytes that get overwritten for reasons I don't understand

*
* Data used for page flips
*
ADDRG2 DATA 1            Add this to Reg 2 to flip screen image page
ADDRG4 EQU  ADDRG2       Add this to Reg 4 to flip the pattern page
ADDRG5 EQU  ADDRG2       Add this to Reg 5 to flip sprite attribute page

* Timer stuff
TIMER  DATA >FFFF        Decrements once every 349.2 ms.
       DATA >FFFC        Leftmost 14-bits decrement once every 21.3 microseconds.
MIDTIM DATA >FFFF        Decrements once every 1.363 ms.
*                        Holds the same value as the word at TIMER+1.

FLIPTM DATA >FFF0        When MIDTIM <= this value, go to next animation frame
ANIADR DATA HEROMV       Address of the next pair of hero characters to display in animation
HERODR DATA 0            Specifies if hero is facing right
HEROSL DATA 0            Specifies if hero is standing still

       AORG >83F0
STACKL BSS  >10
STACKH

       RORG
*
* End of Editable values
*

VDPR1  DATA >01E2        Initial value of VDP register 1
VDPR2A DATA >0200        Initial value of VDP register 2 (page 1 of screen image table)
VDPR2B DATA >0201        Secndry value of VDP register 2 (page 2 of screen image table)
VDPR4  DATA >0401        Initial value of VDP register 4
VDPR5A DATA >0540        Initial value of VDP register 5 (page 1 of sprite attribute list)
VDPR5B DATA >0541        Secndry value of VDP register 5 (page 2 of sprite attribute list)
VDPR6  DATA >0603        Initial value of VDP register 6
VDPR7  DATA >0701        Initial value of VDP register 7

WAITTM DATA 35           Amount of time to wait between hero animation frames

* Initial contents of sprite attribute table
SPRATT DATA >5070,>0002
       DATA >6070,>0402
       DATA >D000

* Codes for character moving right.
HEROMV BYTE >00,>04
       BYTE >00,>04
       BYTE >00,>04
       BYTE >08,>0C
       BYTE >08,>0C
       BYTE >10,>14
       BYTE >10,>14
       BYTE >10,>14
       BYTE >18,>1C
       BYTE >18,>1C
HEROED
* Codes for character standing still looking right.
HEROST BYTE >20,>24
       EVEN

RUNTST LWPI LOCLWS
* Initialize Stack
       LI   R10,STACKH
* Initialize Game
       BL   @INTGAM
       BL   @INTSPR
GAMELP 
* Update timer
       BL   @TRCKTM
* Process user input
       BL   @USRIPT
* Redraw hero sprite
       BL   @HEROSP
*
       JMP  GAMELP


*
* Initialize game
*
INTGAM DECT R10
       MOV  R11,*R10
*
       MOVB @VDPR1+1,@REG1CP
       MOV  @VDPR1,R0
       BL   @VWTR
       MOV  @VDPR2A,R0
       BL   @VWTR
       MOV  @VDPR4,R0
       BL   @VWTR
       MOV  @VDPR5A,R0
       BL   @VWTR
       MOV  @VDPR6,R0
       BL   @VWTR
       MOV  @VDPR7,R0
       BL   @VWTR
* Color table
       LI   R0,CLRTBL+4
       LI   R1,>1000
       BL   @VSBW
* Clear Screen for page 2
       LI   R0,SCNPG2
       LI   R1,>2000
INTG1  BL   @VSBW
       INC  R0
       CI   R0,SCNPG2+>300
       JL   INTG1
* Initialize Timer
       CLR  R12         CRU base of the TMS9901 
       SBO  0           Enter timer mode 
       LI   R1,>3FFF    Maximum value
       INCT R12         Address of bit 1 
       LDCR R1,14       Load value 
       DECT R12
       SBZ  0           Exit clock mode, start decrementer 
*
       MOV  *R10+,R11
       RT

*
* Initialize Sprite Patterns
*
INTSPR DECT R10
       MOV  R11,*R10
* Record sprite values
       LI   R0,SPRTBL
       LI   R1,SPR0
       LI   R2,SPRLEN
       BL   @VMBW
* Record initial sprite attributes
       LI   R0,SPRPG1
       LI   R1,SPRATT
       LI   R2,9
       BL   @VMBW
       LI   R0,SPRPG2
       BL   @VMBW
*
       MOV  *R10+,R11
       RT

*
* Track Time
*
TRCKTM CLR  R12 
       SBO  0           Enter timer mode 
       STCR R2,15       Read current value (plus mode bit)
       SBZ  0
       SRL  R2,1        Get rid of mode bit
       SLA  R2,2
       C    R2,@TIMER+2
       JL   TRCK1
       DEC  @TIMER
TRCK1  MOV  R2,@TIMER+2
       MOVB @TIMER+1,@MIDTIM
       MOVB @TIMER+2,@MIDTIM+1
       RT

*
* Scan for user input
*
USRIPT DECT R10
       MOV  R11,*R10
* Scan for left move
       LI   R2,>0100
       BL   @KYSCAN
       CZC  @RWLEFT,R3
       JEQ  MOVLFT
* Scan for right move
       LI   R2,>0200
       BL   @KYSCAN
       CZC  @RWRGHT,R3
       JEQ  MOVRGT
* Note that the user isn't moving the hero
       CLR  @HEROSL
       JMP  USRRTN
* Note that the user is moving the hero left
MOVLFT SETO @HERODR
       SETO @HEROSL
       JMP  USRRTN
* Note that the user is moving the hero right
MOVRGT CLR  @HERODR
       SETO @HEROSL
USRRTN MOV  *R10+,R11
       RT
* Left keyboard row
RWLEFT DATA >2000
* Right keyboard row
RWRGHT EQU  RWLEFT

* Scan
* R2 - keyboard column to scan (left-most byte)
*
* Select column to scan
KYSCAN LI   R12,>0024
       LDCR R2,3
* Put scaned keyboard rows in R3 (left-most byte)
       LI   R12,>0006
       CLR  R3
       STCR R3,8
       RT

*
* Redraw hero sprite
*
HEROSP DECT R10
       MOV  R11,*R10
* Confirm enough time has passed
       MOV  @MIDTIM,R0
       S    @FLIPTM,R0
       JGT  HEROR2
* Redraw hero sprite, either moving or standing still
       MOV  @HEROSL,R0
       JNE  MOVANI
* Display sprite as standing still
       MOV  @HEROST,R1
       BL   @HEROPK
*
       MOV  *R10+,R11
       RT
* Animate hero sprite as it moves
MOVANI S    @WAITTM,@FLIPTM
* Move to next frame
       MOV  @ANIADR,R5
       MOV  *R5+,R1
       BL   @HEROPK
* Restart animation loop if necessary
       CI   R5,HEROED
       JL   HERORT
       LI   R5,HEROMV
* Store next set of characters for animation
HERORT MOV  R5,@ANIADR
*
HEROR2 MOV  *R10+,R11
       RT

* Write the next set of hero character codes to VDP RAM
* R1 is expected to have two character codes, one in each byte.
HEROPK DECT R10
       MOV  R11,*R10
* If hero direction is "left", at >80 to each character code.
       MOV  @HERODR,R2
       JEQ  MOVE1
       AI   R1,>8080
* Select which page of the sprite attribute list we plan to write to
MOVE1  LI   R0,SPRPG1+2
       MOV  @ADDRG2,@ADDRG2
       JLT  MOVE2
       LI   R0,SPRPG2+2
* Write both character codes
MOVE2  BL   @VSBW
       SWPB R1
       AI   R0,4
       BL   @VSBW
* Flip page
       BL   @FLIPPG
*
       MOV  *R10+,R11
       RT

*
* Flip Page
*
FLIPPG DECT R10
       MOV  R11,*R10
*
       MOV  @ADDRG2,@ADDRG2
       JGT  FLIP2
* Switch to page 1DDD
FLIP1  MOV  @VDPR2A,R0
       BL   @VWTR
       MOV  @VDPR5A,R0
       BL   @VWTR
       JMP  FLIPNG
* Switch to page 2
FLIP2  MOV  @VDPR2B,R0
       BL   @VWTR
       MOV  @VDPR5B,R0
       BL   @VWTR
* Specify the what the next page will be,
* the page you shoud now write to.
FLIPNG NEG  @ADDRG2
*
       MOV  *R10+,R11
       RT

*
* VDP RAM access
*

BIT0   DATA >8000
BIT1   DATA >4000
VSBW   DECT R10
       MOV  R0,*R10
* Specify that we wish to write to the VDP RAM
       SZC  @BIT0,R0                  Set most signfication bit for writing
       SOC  @BIT1,R0                  Set second most signfication bit for writing
* Specify VDP address (write least-signficant byte first)
       SWPB R0
       MOVB R0,@VDPWA
       SWPB R0
       MOVB R0,@VDPWA
* Specify data to write
       NOP
       MOVB R1,@VDPWD
*
       MOV  *R10+,R0
       RT

VMBW   DECT R10
       MOV  R0,*R10
       DECT R10
       MOV  R1,*R10
       DECT R10
       MOV  R2,*R10
* Specify that we wish to write to the VDP RAM
       SZC  @BIT0,R0                  Set most signfication bit for writing
       SOC  @BIT1,R0                  Set second most signfication bit for writing
* Specify VDP address (write least-signficant byte first)
       SWPB R0
       MOVB R0,@VDPWA
       SWPB R0
       MOVB R0,@VDPWA
* Specify data to write
       NOP
VMBW1  MOVB *R1+,@VDPWD
       DEC  R2
       JNE  VMBW1
*
       MOV  *R10+,R2
       MOV  *R10+,R1
       MOV  *R10+,R0
       RT

VWTR   DECT R10
       MOV  R0,*R10
* Specify that we are changing a registers
       SOC  @BIT0,R0
       SZC  @BIT1,R0
* Write new value to VDP register
       SWPB R0
       MOVB R0,@VDPWA
* Specify VDP register to change
       SWPB R0
       MOVB R0,@VDPWA
*
       MOV  *R10+,R0
       RT
       END