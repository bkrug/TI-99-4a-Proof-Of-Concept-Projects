       DEF  RUNTST
       REF  SPR0,SPREND,SPRLEN

* A program to test shifting the screen left and right
* This scroll method involves defining grops of 8 characters
* Each character in the group is pixel-shifted by one
* relative to the earlier character.
*
* Use this file together with HSCROLLDAT and FIXEDDAT

* CPU RAM Addresses
USRISR EQU  >83C4        Address defining address of interupt routine
REG1CP EQU  >83D4        Address holding a copy of VDP Register 1
VDPWA  EQU  >8C02        VDP RAM write address
VDPRD  EQU  >8800        VDP RAM read data
VDPWD  EQU  >8C00        VDP RAM write data
VDPSTA EQU  >8802        VDP RAM status
* VDP RAM Addresses
SPRTBL EQU  >1800        Address of Sprite Pattern Table
CLRTBL EQU  >380         Address of Color Table
PTNPG1 EQU  >800         Address of Character Pattern Table 1
PTNPG2 EQU  >1000        Address of Character Pattern Table 2
SCNPG1 EQU  >0           Address of Page 1 of the screen image table
SCNPG2 EQU  >400         Address of Page 2 of the screen image table
SPRPG1 EQU  >2000        Address of Page 1 of the sprite attribute list
SPRPG2 EQU  >2080        Address of Page 2 of the sprite attribute list

*
* Editable values
*
       AORG >8300

LOCLWS BSS  >20          Local Workspace
       BSS  >8           8 Bytes that get overwritten for reasons I don't understand

*
* Data used for page flips
*
ADDRG2 DATA 1            Add this to Reg 2 to flip screen image page
ADDRG4 EQU  ADDRG2       Add this to Reg 4 to flip the pattern page
ADDRG5 EQU  ADDRG2       Add this to Reg 5 to flip sprite attribute page
VDPRG1 DATA >01E2        Current value of VDP register 1
VDPRG2 DATA >0200        Current value of VDP register 2
VDPRG4 DATA >0401        Current value of VDP register 4
VDPRG5 DATA >0540        Current value of VDP register 5
VDPRG6 DATA >0603        Current value of VDP register 6
VDPRG7 DATA >0701        Current value of VDP register 7

* Timer stuff
TIMER  DATA >FFFF        Decrements once every 349.2 ms.
       DATA >FFFC        Leftmost 14-bits decrement once every 21.3 microseconds.
MIDTIM DATA >FFFF        Decrements once every 1.363 ms.
*                        Holds the same value as the word at TIMER+1.

FLIPTM DATA >FFF0        When MIDTIM <= this value, go to next animation frame
ANIADR DATA HEROMV       Address of the next pair of hero characters to display in animation
HERODR DATA 0            Specifies if hero is facing right
HEROSL DATA 0            Specifies if hero is standing still

       AORG >83F0
STACKL BSS  >10
STACKH

       RORG
*
* End of Editable values
*

WAITTM DATA 35           Amount of time to wait between hero animation frames

* Initial contents of sprite attribute table
SPRATT DATA >5070,>0002
       DATA >6070,>0402
       DATA >D000

* Codes for character moving right.
HEROMV BYTE >00,>04
       BYTE >00,>04
       BYTE >00,>04
       BYTE >08,>0C
       BYTE >08,>0C
       BYTE >10,>14
       BYTE >10,>14
       BYTE >10,>14
       BYTE >18,>1C
       BYTE >18,>1C
HEROED
* Codes for character standing still looking right.
HEROST BYTE >20,>24
       EVEN

RUNTST LWPI LOCLWS
* Initialize Stack
       LI   R10,STACKH
* Initialize Game
       BL   @INTGAM
       BL   @INTSPR
GAMELP 
* Update timer
       BL   @TRCKTM
* Process user input
       BL   @USRIPT
* Redraw hero sprite
       BL   @HEROSP
*
       JMP  GAMELP


*
* Initialize game
*
INTGAM DECT R10
       MOV  R11,*R10
*
       MOVB @VDPRG1+1,@REG1CP
       MOV  @VDPRG1,R0
       BL   @VWTR
       MOV  @VDPRG2,R0
       BL   @VWTR
       MOV  @VDPRG4,R0
       BL   @VWTR
       MOV  @VDPRG5,R0
       BL   @VWTR
       MOV  @VDPRG6,R0
       BL   @VWTR
       MOV  @VDPRG7,R0
       BL   @VWTR
* Color table
       LI   R0,CLRTBL+4
       LI   R1,>1000
       BL   @VSBW
* Initialize Timer
       CLR  R12         CRU base of the TMS9901 
       SBO  0           Enter timer mode 
       LI   R1,>3FFF    Maximum value
       INCT R12         Address of bit 1 
       LDCR R1,14       Load value 
       DECT R12
       SBZ  0           Exit clock mode, start decrementer 
*
       MOV  *R10+,R11
       RT

*
* Initialize Sprite Patterns
*
INTSPR DECT R10
       MOV  R11,*R10
* Record sprite values
       LI   R0,SPRTBL
       LI   R1,SPR0
       LI   R2,SPRLEN
       BL   @VMBW
* Record initial sprite attributes
       LI   R0,SPRPG1
       LI   R1,SPRATT
       LI   R2,9
       BL   @VMBW
*
       MOV  *R10+,R11
       RT

*
* Track Time
*
TRCKTM CLR  R12 
       SBO  0           Enter timer mode 
       STCR R2,15       Read current value (plus mode bit)
       SBZ  0
       SRL  R2,1        Get rid of mode bit
       SLA  R2,2
       C    R2,@TIMER+2
       JL   TRCK1
       DEC  @TIMER
TRCK1  MOV  R2,@TIMER+2
       MOVB @TIMER+1,@MIDTIM
       MOVB @TIMER+2,@MIDTIM+1
       RT

*
* Scan for user input
*
USRIPT DECT R10
       MOV  R11,*R10
* Scan for left move
       LI   R2,>0100
       BL   @KYSCAN
       CZC  @RWLEFT,R3
       JEQ  MOVLFT
* Scan for right move
       LI   R2,>0200
       BL   @KYSCAN
       CZC  @RWRGHT,R3
       JEQ  MOVRGT
* Note that the user isn't moving the hero
       CLR  @HEROSL
       JMP  USRRTN
* Note that the user is moving the hero left
MOVLFT SETO @HERODR
       SETO @HEROSL
       JMP  USRRTN
* Note that the user is moving the hero right
MOVRGT CLR  @HERODR
       SETO @HEROSL
USRRTN MOV  *R10+,R11
       RT
* Left keyboard row
RWLEFT DATA >2000
* Right keyboard row
RWRGHT EQU  RWLEFT

* Scan
* R2 - keyboard column to scan (left-most byte)
*
* Select column to scan
KYSCAN LI   R12,>0024
       LDCR R2,3
* Put scaned keyboard rows in R3 (left-most byte)
       LI   R12,>0006
       CLR  R3
       STCR R3,8
       RT

*
* Redraw hero sprite
*
HEROSP DECT R10
       MOV  R11,*R10
* Confirm enough time has passed
       MOV  @MIDTIM,R0
       S    @FLIPTM,R0
       JGT  HERORT
* Redraw hero sprite, either moving or standing still
       MOV  @HEROSL,R0
       JNE  MOVANI
* Display sprite as standing still
       MOV  @HEROST,R1
       BL   @HEROPK
       MOV  *R10+,R11
       RT
* Animate hero sprite as it moves
MOVANI S    @WAITTM,@FLIPTM
* Move to next frame
       MOV  @ANIADR,R5
       MOV  *R5+,R1
       BL   @HEROPK
* Restart animation loop if necessary
       CI   R5,HEROED
       JL   HERORT
       LI   R5,HEROMV
* Store next set of characters for animation
HERORT MOV  R5,@ANIADR
       MOV  *R10+,R11
       RT

* Pass the new hero characters from R1 to VDP RAM
* R1 is expected to have two characters, one in each byte.
* If hero direction is "left", at >80 to each character code.
HEROPK DECT R10
       MOV  R11,*R10
*
       MOV  @HERODR,R2
       JEQ  MOVE1
       AI   R1,>8080
MOVE1  LI   R0,SPRPG1+2
       BL   @VSBW
       SWPB R1
       LI   R0,SPRPG1+6
       BL   @VSBW
*
       MOV  *R10+,R11
       RT

*
* Flip Page
*
FLIPPG
* Flip page for screen image table, pattern table, sprite attribute list
       A    @ADDRG2,@VDPRG2
       A    @ADDRG4,@VDPRG4
       A    @ADDRG5,@VDPRG5
       MOV  @VDPRG2,R0
       BL   @VWTR
       MOV  @VDPRG4,R0
       BL   @VWTR
       MOV  @VDPRG5,R0
       BL   @VWTR
* Simultaneously negates ADDRG4 and ADDRG5
       NEG  @ADDRG2
       RT

*
* VDP RAM access
*

BIT0   DATA >8000
BIT1   DATA >4000
VSBW   DECT R10
       MOV  R0,*R10
* Specify that we wish to write to the VDP RAM
       SZC  @BIT0,R0                  Set most signfication bit for writing
       SOC  @BIT1,R0                  Set second most signfication bit for writing
* Specify VDP address (write least-signficant byte first)
       SWPB R0
       MOVB R0,@VDPWA
       SWPB R0
       MOVB R0,@VDPWA
* Specify data to write
       NOP
       MOVB R1,@VDPWD
*
       MOV  *R10+,R0
       RT

VMBW   DECT R10
       MOV  R0,*R10
       DECT R10
       MOV  R2,*R10
* Specify that we wish to write to the VDP RAM
       SZC  @BIT0,R0                  Set most signfication bit for writing
       SOC  @BIT1,R0                  Set second most signfication bit for writing
* Specify VDP address (write least-signficant byte first)
       SWPB R0
       MOVB R0,@VDPWA
       SWPB R0
       MOVB R0,@VDPWA
* Specify data to write
       NOP
VMBW1  MOVB *R1+,@VDPWD
       DEC  R2
       JNE  VMBW1
*
       MOV  *R10+,R2
       MOV  *R10+,R0
       RT

VWTR   DECT R10
       MOV  R0,*R10
* Specify that we are changing a registers
       SOC  @BIT0,R0
       SZC  @BIT1,R0
* Write new value to VDP register
       SWPB R0
       MOVB R0,@VDPWA
* Specify VDP register to change
       SWPB R0
       MOVB R0,@VDPWA
*
       MOV  *R10+,R0
       RT
       END