       DEF  RUNTST
       REF  SPR0,SPREND,SPRLEN
       REF  MP01HD

* A program to test shifting the screen left and right
* This scroll method involves defining grops of 8 characters
* Each character in the group is pixel-shifted by one
* relative to the earlier character.
*
* Use this file together with HSCROLLDAT and FIXEDDAT

*
* Editable values
*
       AORG >8300

LOCLWS BSS  >20          Local Workspace
* 8 Bytes that get overwritten between loading and running the program
* you can still use this space if you wait until the program is running to initialize it.
       DATA >F1F2,>F3F4,>F5F6,>F7F8

*
* Data used for page flips
*
NEXTPG DATA 1            Next page to flip to. -1 implies page 1. +1 implies page 2.

* Timer stuff
TIMER  DATA >FFFF        Decrements once every 349.2 ms.
       DATA >FFFC        Leftmost 14-bits decrement once every 21.3 microseconds.
MIDTIM DATA >FFFF        Decrements once every 1.363 ms.
*                        Holds the same value as the word at TIMER+1.

FLIPTM DATA >FFFF        When MIDTIM <= this value, go to next animation frame
KEYTM  DATA >FFFF        When MIDTIM <= this value, it is okay to accept a key press
ANIADR DATA HEROMV       Address of the next pair of hero characters to display in animation
HERODR DATA 0            If 0, hero is facing right
HEROSL DATA 0            If 0, hero is standing still
DRAWNW DATA 0            If 0, Screen is out of date
*
MAPX   DATA 0            Current horizontal scroll amount for the map
HEROX  DATA >60          Current x position of hero within the map
*
MAPWD  DATA 0            Width of current map
MAPXT  DATA 0            Width of current map - 32 (screen width)
* Used to create shifted version of characters
PATBUF BSS  64
PATEND
*
MINSCL BYTE 0            Minimum scrollable character
       EVEN

       AORG >83F0
STACKL BSS  >10
STACKH

       RORG
*
* End of Editable values
*

* CPU RAM Addresses
USRISR EQU  >83C4        Address defining address of interupt routine
REG1CP EQU  >83D4        Address holding a copy of VDP Register 1
VDPWA  EQU  >8C02        VDP RAM write address
VDPRD  EQU  >8800        VDP RAM read data
VDPWD  EQU  >8C00        VDP RAM write data
VDPSTA EQU  >8802        VDP RAM status
* VDP RAM Addresses
SCNPG1 EQU  >0           Address of Page 1 of the screen image table
SCNPG2 EQU  >400         Address of Page 2 of the screen image table
CLRTBL EQU  >380         Address of Color Table
SPRPG1 EQU  >700         Address of Page 1 of the sprite attribute list
SPRPG2 EQU  >780         Address of Page 2 of the sprite attribute list
PTNPG1 EQU  >800         Address of Character Pattern Table 1
*PTNPG2 EQU  >1000        Address of Character Pattern Table 2
SPRTBL EQU  >1800        Address of Sprite Pattern Table

VDPR1  DATA >01E2        Initial value of VDP register 1 (Set sprite type)
VDPR2A DATA >0200        Initial value of VDP register 2 (page 1 of screen image table)
VDPR2B DATA >0201        Secndry value of VDP register 2 (page 2 of screen image table)
VDPR4  DATA >0401        Initial value of VDP register 4 (Pattern Descriptor Table)
VDPR5A DATA >050E        Initial value of VDP register 5 (page 1 of sprite attribute list)
VDPR5B DATA >050F        Secndry value of VDP register 5 (page 2 of sprite attribute list)
VDPR6  DATA >0603        Initial value of VDP register 6 (Sprite Descriptor Table)
VDPR7  DATA >0701        Initial value of VDP register 7 (background color)

HEROWT DATA 20           Amount of time to wait between hero animation frames
KEYWT  DATA 8            Amount of time to wait between accepting key presses

MXOFST DATA >70          The hero's right-most offset should not exceed this value accept at the right-edge of the map.
MNOFST DATA >60          The hero's left-most offset should not drop below this value accept at the left-edge of the map.

* Initial contents of sprite attribute table
SPRATT DATA >A070,>0002
       DATA >B070,>0402
       DATA >D000

* Codes for character moving right.
HEROMV BYTE >00,>04
       BYTE >00,>04
       BYTE >00,>04
       BYTE >08,>0C
       BYTE >08,>0C
       BYTE >10,>14
       BYTE >10,>14
       BYTE >10,>14
       BYTE >18,>1C
       BYTE >18,>1C
HEROED
* Codes for character standing still looking right.
HEROST BYTE >20,>24
*
BYTE01 BYTE >01
BYTEFF BYTE >FF
       EVEN

RUNTST LWPI LOCLWS
* Initialize Stack
       LI   R10,STACKH
* Initialize Game
       BL   @INTGAM
       BL   @INTSPR
       LI   R9,MP01HD
       BL   @INTMAP
GAMELP 
* Update timer
       BL   @TRCKTM
* Process user input
       BL   @USRIPT
*
       MOV  @DRAWNW,R0
       JNE  GAMELP
       SETO @DRAWNW
*
       LI   R0,>60
       LI   R2,MP01HD
       BL   @DRWMAP
* Redraw hero sprite
       BL   @HEROSP
*
       JMP  GAMELP


*
* Initialize game
*
INTGAM DECT R10
       MOV  R11,*R10
*
       MOVB @VDPR1+1,@REG1CP
       MOV  @VDPR1,R0
       BL   @VWTR
       MOV  @VDPR2A,R0
       BL   @VWTR
       MOV  @VDPR4,R0
       BL   @VWTR
       MOV  @VDPR5A,R0
       BL   @VWTR
       MOV  @VDPR6,R0
       BL   @VWTR
       MOV  @VDPR7,R0
       BL   @VWTR
* Color table
       LI   R0,CLRTBL+4
       LI   R1,>1000
       BL   @VSBW
* Clear Screen for page 2
       LI   R0,SCNPG2
       LI   R1,>2000
INTG1  BL   @VSBW
       INC  R0
       CI   R0,SCNPG2+>300
       JL   INTG1
* Initialize Timer
       CLR  R12         CRU base of the TMS9901 
       SBO  0           Enter timer mode 
       LI   R1,>3FFF    Maximum value
       INCT R12         Address of bit 1 
       LDCR R1,14       Load value 
       DECT R12
       SBZ  0           Exit clock mode, start decrementer 
*
       MOV  *R10+,R11
       RT

*
* Initialize Sprite Patterns
*
INTSPR DECT R10
       MOV  R11,*R10
* Record sprite values
       LI   R0,SPRTBL
       LI   R1,SPR0
       LI   R2,SPRLEN
       BL   @VMBW
* Record initial sprite attributes
       LI   R0,SPRPG1
       LI   R1,SPRATT
       LI   R2,9
       BL   @VMBW
       LI   R0,SPRPG2
       BL   @VMBW
*
       MOV  *R10+,R11
       RT

*
* Initialize Map
*
* R9 - Address of map header
MAPCOL EQU  0
MAPROW EQU  2
MAPSIZ EQU  4
COLORB EQU  6
COLORD EQU  8
COLORG EQU  10
PATRNB EQU  12
PATRND EQU  14
PATRNG EQU  16
SCRENB EQU  18
SCREND EQU  20
SCRENG EQU  22
INTMAP DECT R10
       MOV  R11,*R10
* Record map width values
       MOV  *R9,R0
       MOV  R0,@MAPWD
       AI   R0,-32
       MOV  R0,@MAPXT
* Record minimum scrollable character
       MOV  @PATRNB(9),R0
       MOV  *R0,R0
       SWPB R0
       MOVB R0,@MINSCL
* Write color definitions
       SRL  R0,11                  Find value of minimum scrollable character / 8
       AI   R0,CLRTBL
       MOV  @COLORB(9),R1         * >A8C0
       MOV  @COLORG(9),R2         * >14
       BL   @VMBW
* Write character patterns from >60
* We are copying portions of 16-pixel characters
* to 8-pixel characters
* R3 - VDP address
* R4 - address of leftmost 8 pixels
* R5 - address of rightmost 8 pixels
* R7 - 16 pixels
* R8 - address of end of pattern data
       MOVB @MINSCL,R3
       SWPB R3
       SLA  R3,3
       AI   R3,PTNPG1              R3 = first char code * 8 + pattern table address
       MOV  @PATRNB(9),R4
       AI   R4,2
       MOV  @PATRNB(9),R5
       AI   R5,10
       MOV  @PATRND(9),R8
CHAR0  LI   R6,PATBUF
CHAR1  MOVB *R5+,R7
       SWPB R7
       MOVB *R4+,R7
CHAR2  MOVB R7,*R6
       SLA  R7,1
       AI   R6,8
       CI   R6,PATEND
       JL   CHAR2
       AI   R6,PATBUF-PATEND+1
       CI   R6,PATBUF+8
       JL   CHAR1
       MOV  R3,R0
       LI   R1,PATBUF
       LI   R2,PATEND-PATBUF
       BL   @VMBW
       AI   R3,8*8
       AI   R4,8
       AI   R5,8
       C    R4,R8
       JL   CHAR0
*
       MOV  *R10+,R11
       RT

*
* Track Time
*
TRCKTM CLR  R12 
       SBO  0           Enter timer mode 
       STCR R2,15       Read current value (plus mode bit)
       SBZ  0
       SRL  R2,1        Get rid of mode bit
       SLA  R2,2
       C    R2,@TIMER+2
       JL   TRCK1
       DEC  @TIMER
TRCK1  MOV  R2,@TIMER+2
       MOVB @TIMER+1,@MIDTIM
       MOVB @TIMER+2,@MIDTIM+1
       RT

*
* Scan for user input
*
USRIPT DECT R10
       MOV  R11,*R10
* If user pressed key recently, return to caller
       MOV  @MIDTIM,R0
       S    @KEYTM,R0
       JGT  USRRTN
* Scan for left move
       LI   R2,>0100
       BL   @KYSCAN
       CZC  @RWLEFT,R3
       JEQ  MOVLFT
* Scan for right move
       LI   R2,>0200
       BL   @KYSCAN
       CZC  @RWRGHT,R3
       JEQ  MOVRGT
* Note if the screen needs to be updated
       MOV  @HEROSL,R0
       JEQ  STILL1
       CLR  @DRAWNW
* Note that the user isn't moving the hero
       CLR  @HEROSL
* No key was pressed. Accept another key right away. Prevent timer cycling bug.
STILL1 MOV  @MIDTIM,@KEYTM
       MOV  @MIDTIM,@FLIPTM
       JMP  USRRTN
* Note that the user is moving the hero left
MOVLFT SETO @HERODR
       SETO @HEROSL
       DEC  @HEROX
* Don't let HEROX drop belwo zero
       JGT  MLFT1
       CLR  @HEROX
* Adjust map position if necessary
MLFT1  MOV  @HEROX,R0
       S    @MNOFST,R0
       C    @MAPX,R0
       JLT  KEYNXT
       MOV  R0,@MAPX                 * Shift map, we move too far left
       JGT  KEYNXT
       CLR  @MAPX                    * We shifted too far, we're close to the left edge of the map
       JMP  KEYNXT
* Note that the user is moving the hero right
MOVRGT CLR  @HERODR
       SETO @HEROSL
       INC  @HEROX
* Don't let HEROX go off right edge of map
       MOV  @MAPWD,R0
       SLA  R0,3
       AI   R0,-16
       C    R0,@HEROX
       JHE  MRGHT1
       MOV  R0,@HEROX
* Adjust map position if necessary
MRGHT1 MOV  @HEROX,R0
       S    @MXOFST,R0
       C    @MAPX,R0
       JGT  KEYNXT
       MOV  R0,@MAPX                * Shift map, we moved too far right
       MOV  @MAPXT,R0
       SLA  R0,3
       C    R0,@MAPX
       JHE  KEYNXT
       MOV  R0,@MAPX                * We shifted too far, we're close to the right edge of the map
* Specify time to wait before accepting another key press
KEYNXT MOV  @MIDTIM,@KEYTM
       S    @KEYWT,@KEYTM
* Note that the screen needs to be updated
       CLR  @DRAWNW
*
USRRTN MOV  *R10+,R11
       RT
* Left keyboard row
RWLEFT DATA >2000
* Right keyboard row
RWRGHT EQU  RWLEFT

* Scan
* R2 - keyboard column to scan (left-most byte)
*
* Select column to scan
KYSCAN LI   R12,>0024
       LDCR R2,3
* Put scaned keyboard rows in R3 (left-most byte)
       LI   R12,>0006
       CLR  R3
       STCR R3,8
       RT

*
* Draw the scrollable map
*
* R0 - Screen location to write to
* R2 - Address of map header
DRWMAP DECT R10
       MOV  R11,*R10
       MOV  R0,R4
* R3 - Pixel Scroll Amount (left-most column)
* R6 - Column Scroll Amount
       MOV  @MAPX,R6
       MOV  R6,R3
       SRL  R6,3
       SLA  R3,13
       SRL  R3,5
*
       BL   @INTCHR
* Store end of map in R8
       MOV  @SCREND(2),R8
* Store position of map in R9
       MOV  @SCRENB(2),R9
       A    R6,R9
* Write one row of characters
HSCRL
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
       MOVB *R9+,R1
       AB   R3,R1
       MOVB R1,@VDPWD
*
       A    @MAPXT,R9                Increase R9 to equal address of next row
       C    R9,R8
       JHE  HSCRL3
       B    @HSCRL
*
HSCRL3
       MOV  *R10+,R11
       RT

*
* Specify the initial screen position to write to.
*
* R0 - a screen position, this routine will determine which byte of VDP RAM to use.
INTCHR MOV  @NEXTPG,@NEXTPG
       JLT  ITCHR0
       AI   R0,SCNPG2
ITCHR0 ORI  R0,>4000               Set write bit to true
       SWPB R0
       MOVB R0,@VDPWA
       SWPB R0
       MOVB R0,@VDPWA
       RT

*
* Redraw hero sprite
*
HEROSP DECT R10
       MOV  R11,*R10
* Confirm enough time has passed
       MOV  @MIDTIM,R0
       S    @FLIPTM,R0
       JGT  HEROR2
* Set next wait time
       S    @HEROWT,@FLIPTM
* Redraw hero sprite, either moving or standing still
       MOV  @HEROSL,R0
       JNE  MOVANI
* Display sprite as standing still
       MOV  @HEROST,R1
       BL   @HEROVD
*
       MOV  *R10+,R11
       RT
* Animate hero sprite as it moves
MOVANI
* Move to next frame
       MOV  @ANIADR,R5
       MOV  *R5+,R1
       BL   @HEROVD
* Restart animation loop if necessary
       CI   R5,HEROED
       JL   HERORT
       LI   R5,HEROMV
* Store next set of characters for animation
HERORT MOV  R5,@ANIADR
*
HEROR2 MOV  *R10+,R11
       RT

* Update the hero-portion of the sprite attribute list in VDP RAM
* R1 is expected to have two character codes, one in each byte.
HEROVD DECT R10
       MOV  R11,*R10
       DECT R10
       MOV  R1,*R10
* Select which page of the sprite attribute list we plan to write to
       LI   R0,SPRPG1+1
       MOV  @NEXTPG,@NEXTPG
       JLT  PK2
       LI   R0,SPRPG2+1
* Respecify hero location
PK2    MOV  @HEROX,R1
       S    @MAPX,R1
       SWPB R1
       BL   @VSBW
       AI   R0,4
       BL   @VSBW
* If hero direction is "left", at >80 to each character code.
       MOV  *R10+,R1
       MOV  @HERODR,R2
       JEQ  PK3
       AI   R1,>8080
* Write both character codes
PK3    AI   R0,-3
       BL   @VSBW
       SWPB R1
       AI   R0,4
       BL   @VSBW
* Flip page
       BL   @FLIPPG
*
       MOV  *R10+,R11
       RT

*
* Flip Page
*
FLIPPG DECT R10
       MOV  R11,*R10
*
       MOV  @NEXTPG,@NEXTPG
       JGT  FLIP2
* Switch to page 1DDD
FLIP1  MOV  @VDPR2A,R0
       BL   @VWTR
       MOV  @VDPR5A,R0
       BL   @VWTR
       JMP  FLIPNG
* Switch to page 2
FLIP2  MOV  @VDPR2B,R0
       BL   @VWTR
       MOV  @VDPR5B,R0
       BL   @VWTR
* Specify the what the next page will be,
* the page you shoud now write to.
FLIPNG NEG  @NEXTPG
*
       MOV  *R10+,R11
       RT

*
* VDP RAM access
*

BIT0   DATA >8000
BIT1   DATA >4000
VSBW   DECT R10
       MOV  R0,*R10
* Specify that we wish to write to the VDP RAM
       SZC  @BIT0,R0                  Set most signfication bit for writing
       SOC  @BIT1,R0                  Set second most signfication bit for writing
* Specify VDP address (write least-signficant byte first)
       SWPB R0
       MOVB R0,@VDPWA
       SWPB R0
       MOVB R0,@VDPWA
* Specify data to write
       NOP
       MOVB R1,@VDPWD
*
       MOV  *R10+,R0
       RT

VMBW   DECT R10
       MOV  R0,*R10
       DECT R10
       MOV  R1,*R10
       DECT R10
       MOV  R2,*R10
* Specify that we wish to write to the VDP RAM
       SZC  @BIT0,R0                  Set most signfication bit for writing
       SOC  @BIT1,R0                  Set second most signfication bit for writing
* Specify VDP address (write least-signficant byte first)
       SWPB R0
       MOVB R0,@VDPWA
       SWPB R0
       MOVB R0,@VDPWA
* Specify data to write
       NOP
VMBW1  MOVB *R1+,@VDPWD
       DEC  R2
       JNE  VMBW1
*
       MOV  *R10+,R2
       MOV  *R10+,R1
       MOV  *R10+,R0
       RT

VWTR   DECT R10
       MOV  R0,*R10
* Specify that we are changing a registers
       SOC  @BIT0,R0
       SZC  @BIT1,R0
* Write new value to VDP register
       SWPB R0
       MOVB R0,@VDPWA
* Specify VDP register to change
       SWPB R0
       MOVB R0,@VDPWA
*
       MOV  *R10+,R0
       RT
       END